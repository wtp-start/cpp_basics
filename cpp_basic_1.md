#### 1、static关键字的作用
1. 全局静态变量
   1. 位于静态存储区，整个程序运行期间一直存在。
   2. 初始化：未定义初始化会被自动初始化为0。
   3. 作用域：在声明它的文件外不可见。
2. 局部静态变量
   1. 位于静态存储区。
   2. 初始化：未定义初始化会被自动初始化为0。
   3. 作用域为局部作用域，只是当函数或语句块结束后，并不被销毁。
3. 静态函数
   1. 函数的定义和声明，默认是exterm，但静态函数只在声明文件中可见。
   2. 只可在本cpp内使用，不于其他cpp中的同名函数引起冲突。
   3. 不要在头文件声明static全局函数，不要在cpp内声明非static的全局函数。
4. 类的静态成员
   1. 静态成员是类的所有对象中共享的成员。
   2. 实现多个对象之间的数据共享。
   3. 无this指针
5. 类的静态函数
   1. 属于类的静态成员，属于类，而非对象。
   2. 不能直接引用类中的非静态成员，要引用的话需要通过对象来引用。
   3. 无this指针。
   4. 可不进行外置声明，直接调用（即不需要声明对象，直接对象::静态函数）。

#### 2、C++与C的区别
1. 设计思想上：C++是面向对象的语言，C是面向过程的语言
   1. 例如吃面：C++是吃面，C是拿起筷子，挑起面条，送入嘴中，吃面，重复至吃完。
2. 语法上：
   1. C++具有三大特性：封装，继承，多态
      1. 封装：隐藏了对象的属性和实现细节，仅提供接口和方法。
      2. 继承：一个对象直接使用另一个对象的属性和方法。
      3. 多态：接口的多种不同实现方式
         1. 静多态：编译期多态，主要通过模板实现。
         2. 动多态：运行期多态，通过虚函数实现。
   2. C++增加了很多类型安全的功能：如强制类型转换
   3. C++支持范式编程：如模板类，函数模板等
   
#### 3、C++中四种cast转换
1. const_cast
   1. 用于将const变量转为非const
   2. 去除的是指向常量对象的指针或引用的常量性，去除常量性的对象必须是指针或引用
2. static_cast
   1. 用于各种隐式转换：如非const转const，void *转指针等
   2. 用于多态向上转化（子类转父类），向下转化不安全缺乏动态安全检查（即男人是人，人不一定是男人）
   3.  用于基本数据类型之间的转换：如：int转char等。安全性也要开发人员来保证
3. dynamic_cast
   1. 用于动态类型转换，只能用于含虚函数的类，用于类层次间的向上和向下转化，只能转指针或引用。
   2. 通过判断在执行该语句时变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
   3. 向下转换，若是非法，指针返回NULL,引用抛异常。
4. reinterpret_cast
   1. 几乎什么都可以转，比如int转指针,可能会出问题，尽量少用。
   2. 可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。
5. 为什么不使用C的强制转换
   1. 看起来什么都能转，但转化不够明确，不能进行错误检查，容易出错。

#### 4、C/C++中指针和引用的区别
1. 指针有自己的一块空间，引用只是一个别名
2. 使用sizeof看指针大小为4，引用则是被引用对象的大小
3. 指针可以被初始化为NULL,引用必须被初始化且必须有是一个已有对象的引用。
4. 作参数传递时，指针需要被解引用（*p = 10;）才可以对对象进行操作，而直接对引用的修改都会改变引用指向的对象。
5. 可以有const指针，但没有const引用。
6. 指针在使用中可以指向其他对象，但引用只能时一个对象的引用，不能被改变。
7. 指针可以有多级指针，引用只有一级。
8. 指针和引用使用++运算符的意义不一样。
9. 如果返回动态内存分配的对象或者内存，必须用指针，引用可能引起内存泄漏。

#### 5、C++中的四个智能指针
1. auto_ptr, shared_ptr, weak_ptr, unique_ptr,其中后三个是c++11支持，第一被弃用了。
2. 作用：在函数结束时自动释放内存空间，不需要手动释放。
3. auto_ptr 
```
auto_ptr<string> p1(new string("cloud"));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错。p2剥夺了p1的所有权，但当程序运行时访问p1将会报错
```
4. unique_ptr(替换auto_ptr)
   1. 独占式拥有，保证同一时间内只有一个智能指针可以指向该对象。
   ···
   unique_ptr<string> p3(new string("auto"));
   unique_ptr<string> p4;
   p4 = p3; //会报错
   ···
   2. 当unique_ptr是一个临时右值时，编译器允许这么做
   ```
   unique_ptr<string> pu3;
   pu3 = unique_ptr<string> (new string(""you)); //不会报错
   ```
   3. 若要将unique_ptr赋给另一个
   ```
   unique_ptr<string> ps1, ps2;
   ps1 = demo("hello");
   ps2 = move(ps1); // 使用std::move，安全的重用这个指针
   ps1 = demo("alexia");
   ```
5. shared_ptr
   1. 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁的时候释放。（计数机制表明资源被几个指针共享）
   2. 通过成员函数use_count()查看资源的所有者个数。
   3. swap交换两个shared_ptr对象（即交换所拥有的对象）。
   4. reset放弃内部对象的所有权或拥有对象的变更，会引起原因对象的引用计数的减少。
   5. get返回内部对象（指针)，由于重载了（）,因此和直接使用对象是一样的。如：shared_ptr<int> sp(new int(1))，sp与sp.get()是等价的。
   6. make_shared<T>(args)返回一个shared_ptr。
   7. shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。
6. weak_ptr
   1. 是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。
   2. 设计的目的就是为了配合shared_ptr。
   3. 它的构造和析构不会引起计数的增加和减少。
   4. weak_ptr是用来解决shared_ptr相互引用时的思索问题。
   ```
   class B;
   class A {
      public:
         ~A() {
            cout << "A delete\n";
         }
         shared_ptr<B> pb_;
   };
   class B {
      public:
         ~B() {
            cout << "B delete\n";
         }
         shared_ptr<A> pa_;
   };
   void fun() {
      shared_ptr<B> pb(new B());
      shared_ptr<A> pa(new A());
      pb->pa_ = pb;
      pa->pb_ = pa;
      count << pb.use_count() << endl;
      count << pa.use_count() << endl;
   }
   int main() {
      fun();
      return 0;  
   }
   ```
   1. pa 和pb相互引用，两个资源的计数为2.跳出函数时，计数为1，导致资源没有被释放（A，B的析构函数没有被调用）。
   2. 如把A中的，shared_ptr pb_；改为weak_ptr pb_；就OK了。
   3. 不能通过weak_ptr直接访问对象的方法。如若B中有方法print()，不能直接pa->pb_->print()，而要先转shared_ptr，如：shared_ptr p = pa->pb_.lock();p->print();
7. 理解
   1. 从较浅的层面：智能指针就是利用一种RAII(资源获取即初始化)的技术对普通的指针进行封装，智能指针的实质是一个对象，行为表现为却像一个指针。
   2. 作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。
   3. 智能指针还有一个作用是把值语义转化成引用语义。

 #### 6、数组和指针的区别和联系
 | 对比点 | 指针 | 数组 |
 | ----| ---- | ---- |
 | 概念 | 相当于一个变量，存放的是其他变量在内存中的地址 | 用于存储多个相同类型数据的集合 |
 | 赋值 | 同类型的指针变量可以相互赋值 | 只能一个一个元素的赋值或拷贝 |
 | 存储方式 | 因其是变量，指针的存储空间不能确定 | 一块连续的内存空间 |
 | sizeof | 4或者8 | 根据实际元素类型和长度决定 |

1. 指针数组和数组指针
   1. 指针数组：实际上是一个数组，数组的每个元素存放的是一个指针类型的元素。
   2. 数组指针：实际是一个指针，指向一个数组。
2. 传参
   1. 数组传参时，退化为指针

#### 7、野指针
1. 就是指向一个已删除的对象或未申请访问受限内存区域的指针。
2. 成因：
   1. 指针变量没有被初始化
   ```
    char *p ; //此时p为野指针
   ```
   2. 指针P被free或delete后，没有置为NULL，让人误以为p是一个合法的指针
   3. 指针操作超越了作用范围。